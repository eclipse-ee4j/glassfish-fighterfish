/*
 * Copyright (c) 2009, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */
package org.glassfish.osgiweb;

import org.glassfish.osgijavaeebase.JarHelper;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.jar.Manifest;
import java.util.logging.Level;
import java.util.logging.Logger;

import java.util.jar.Attributes.Name;

import static org.glassfish.osgiweb.Constants.WEB_CONTEXT_PATH;
import static org.osgi.framework.Constants.BUNDLE_CLASSPATH;
import static org.osgi.framework.Constants.BUNDLE_MANIFESTVERSION;
import static org.osgi.framework.Constants.BUNDLE_SYMBOLICNAME;
import static org.osgi.framework.Constants.BUNDLE_VERSION;
import static org.osgi.framework.Constants.DYNAMICIMPORT_PACKAGE;
import static org.osgi.framework.Constants.IMPORT_PACKAGE;

/**
 * When a deployer installs a bundle with {@link Constants#WEB_BUNDLE_SCHEME}, our registered handler gets a chance to
 * look at the stream and process the MANIFEST.MF. It adds necessary OSGi metadata as specified in section #5.2.1.2 of
 * RFC #66. It uses the following information during computation: - WAR manifest entries, i.e., developer supplied data
 * - Properties supplied via URL query parameters - Other information present in the WAR, e.g., existence of any jar in
 * WEB-INF/lib causes that jar to be added as Bundle-ClassPath. For exact details, refer to the spec.
 */
public final class WARManifestProcessor {

    /**
     * Logger.
     */
    private static final Logger LOGGER = Logger.getLogger(WARManifestProcessor.class.getPackage().getName());

    /**
     * Bundle manifest version.
     */
    private static final String DEFAULT_MAN_VERSION = "2";

    /**
     * Default import package.
     */
    private static final String DEFAULT_IMPORT_PACKAGE = "javax.servlet; javax.servlet.http; version=2.5, " + "javax.servlet.jsp; javax.servlet.jsp.tagext;"
            + "javax.el; javax.servlet.jsp.el; version=2.1";

    /**
     * We always add WEB-INF/classes/, because not adding has the adverse side effect of Bundle-ClassPath defaulting to "."
     * by framework in case there is no lib jar. Don't end with '/' as rfc66 ct does not like it.
     */
    private static final String DEFAULT_BUNDLE_CP = "WEB-INF/classes";

    /**
     * Next bundle symbolic name id.
     */
    private static final AtomicInteger NEXT_BSN_ID = new AtomicInteger();

    /**
     * Bundle symbolic name prefix.
     */
    private static final String DEFAULT_BSN_PREFIX = "org.glassfish.fighterfish.autogenerated_";

    /**
     * These are the query parameters that are understood by this manifest processor. Any other params are directly applied
     * to the final manifest. More over, as per section 128.4.4, presence of any of these parameters mean the input is a
     * WAB. When it is a WAB, we only allow the Web-ContextPath to be customized.
     */
    private static final Name[] SUPPORTED_QUERY_PARAM_NAMES = { new Name(BUNDLE_SYMBOLICNAME), new Name(BUNDLE_VERSION), new Name(BUNDLE_MANIFESTVERSION),
            new Name(IMPORT_PACKAGE), new Name(WEB_CONTEXT_PATH) };

    /**
     * Cannot be instanciated.
     */
    private WARManifestProcessor() {
    }

    /**
     * Read query parameters.
     *
     * @param query the query
     * @return resolved parameters
     */
    public static Map<String, String> readQueryParams(final String query) {

        Map<String, String> queryParams = new HashMap<String, String>();
        if (query != null) {
            LOGGER.logp(Level.FINE, "WARManifestProcessor", "readQueryParams", "Input query params = {0}", new Object[] { query });
            // "&" separates query paremeters
            StringTokenizer st = new StringTokenizer(query, "&");
            while (st.hasMoreTokens()) {
                String next = st.nextToken();
                int eq = next.indexOf("=");
                String name = next, value = null;
                if (eq != -1) {
                    name = next.substring(0, eq);
                    if ((eq + 1) < next.length()) {
                        value = next.substring(eq + 1);
                    }
                }
                // Canonicalize parameter names. The spec says that the query
                // param names can be case insensitive.
                for (Name supportedQueryParamName : SUPPORTED_QUERY_PARAM_NAMES) {
                    if (supportedQueryParamName.toString().equalsIgnoreCase(name)) {
                        name = supportedQueryParamName.toString();
                    }
                }
                queryParams.put(name, value);
            }
            LOGGER.logp(Level.FINE, "WARManifestProcessor", "readQueryParams", "Canonicalized query params = {0}", new Object[] { queryParams });
        }
        return queryParams;
    }

    /**
     * Reads content of the given URL, uses it to come up with a new Manifest.
     *
     * @param url URL which is used to read the original Manifest and other data
     * @param query extra parameters passed by deployer
     * @return a new Manifest
     * @throws java.io.IOException if IO related error occurs
     */
    public static Manifest processManifest(final URL url, final String query) throws IOException {

        final JarInputStream jis = new JarInputStream(url.openStream());
        try {
            Manifest oldManifest = jis.getManifest();
            Manifest newManifest = new Manifest(oldManifest);
            Attributes attrs = newManifest.getMainAttributes();
            Map<String, String> queryParams = readQueryParams(decode(query));

            // For WAB Modification, the Web URL Handler must only support the
            // Web-ContextPath parameter and it must not modify any existing
            // headers other than the Web-ContextPath. Any other parameter
            // given must result in a Bundle Exception. See section: 128.4.4 of
            // r4.2 spec.
            // Since Web-ContextPath must always be set, we can safely assume
            // that size() can only be 1
            if (isWAB(jis)) {
                if (queryParams.keySet().size() != 1) {
                    throw new IllegalArgumentException("Only Web-ContextPath can be customized using" + " webbundle scheme for a WAB");
                }
                processWCP(queryParams, attrs);
            } else {
                processWCP(queryParams, attrs);
                processBMV(queryParams, attrs);
                processBSN(queryParams, attrs);
                processBV(queryParams, attrs);
                processBCP(queryParams, attrs, jis);
                processIP(queryParams, attrs);

                // We add this attribute until we have added support for
                // scanning class bytes to figure out import dependencies.
                attrs.putValue(DYNAMICIMPORT_PACKAGE, "*");

                // remove all signatures as per section 128.4.6 of the
                // r42 spec.
                processSignatures(newManifest);
            }
            LOGGER.logp(Level.FINE, "WARManifestProcessor", "processManifest", "New Attributes of the bundle = {0}", new Object[] { attrs });
            // for debugging purpose, write this out
            newManifest.write(System.err);
            return newManifest;
        } finally {
            jis.close();
        }
    }

    /**
     * Decode an encoded query.
     *
     * @param encodedQuery the query
     * @return the decoded query string
     */
    private static String decode(final String encodedQuery) {
        LOGGER.logp(Level.FINE, "WARManifestProcessor", "decode", "encodedQuery = {0}", new Object[] { encodedQuery });
        String decodedQuery;
        try {
            decodedQuery = new URI("http://localhost/index.html?" + encodedQuery).getQuery();
        } catch (URISyntaxException e) {
            // Assume this is already decoded and proceeed. This is needed to
            // work around OSGi CT issue #1736
            LOGGER.logp(Level.INFO, "WARManifestProcessor", "decode", "Assuming this is already decoded because of {0} ", new Object[] { e });
            decodedQuery = encodedQuery;
        }
        LOGGER.logp(Level.FINE, "WARManifestProcessor", "decode", "decodedQuery = {0}", new Object[] { decodedQuery });
        return decodedQuery;
    }

    /**
     * Test if the given JAR input stream is a WAB.
     *
     * @param jis the input stream
     * @return {@code true} if a WAR, {@code false} otherwise
     */
    private static boolean isWAB(final JarInputStream jis) {
        Attributes attrs = jis.getManifest().getMainAttributes();
        return !Collections.disjoint(attrs.keySet(), Arrays.asList(SUPPORTED_QUERY_PARAM_NAMES));
    }

    /**
     * Process the web context path.
     *
     * @param queryParams the query parameters
     * @param attrs the attributes to store the result
     */
    private static void processWCP(final Map<String, String> queryParams, final Attributes attrs) {
        String contextPath = queryParams.get(Constants.WEB_CONTEXT_PATH);
        if (!contextPath.startsWith("/")) {
            // spec requires us to prefix '/' if not there.
            contextPath = "/" + contextPath;
        }
        attrs.putValue(Constants.WEB_CONTEXT_PATH, contextPath);
    }

    /**
     * Process bundle manifest version.
     *
     * @param queryParams the query parameters
     * @param attrs attributes to store the result
     */
    private static void processBMV(final Map<String, String> queryParams, final Attributes attrs) {

        process(queryParams, attrs, BUNDLE_MANIFESTVERSION, DEFAULT_MAN_VERSION);
    }

    /**
     * Process bundle symbolic name.
     *
     * @param queryParams the query parameters
     * @param attrs the attributes to store the results
     */
    private static void processBSN(final Map<String, String> queryParams, final Attributes attrs) {

        // We generate symbolic name by incrementing a number and appending it
        // to a fixed string
        String defaultSymName = DEFAULT_BSN_PREFIX + NEXT_BSN_ID.getAndIncrement();
        process(queryParams, attrs, BUNDLE_SYMBOLICNAME, defaultSymName);
    }

    /**
     * Process bundle version.
     *
     * @param queryParams query parameters
     * @param attrs attributes to store the result
     */
    private static void processBV(final Map<String, String> queryParams, final Attributes attrs) {

        process(queryParams, attrs, BUNDLE_VERSION, null);
    }

    /**
     * Process bundle class-path.
     *
     * @param queryParams the query parameters
     * @param attrs the attributes to store the result
     * @param jis the JAR input stream
     * @throws IOException if an error occurs while reading the input stream
     */
    private static void processBCP(final Map<String, String> queryParams, final Attributes attrs, final JarInputStream jis) throws IOException {

        JarVisitorImpl visitor = new JarVisitorImpl(jis);
        JarHelper.accept(jis, visitor);
        String cp = convertToCP(visitor.getLibs(), visitor.getJarNames());
        if (cp.length() > 0) {
            cp = DEFAULT_BUNDLE_CP.concat(",").concat(cp);
        } else {
            cp = DEFAULT_BUNDLE_CP;
        }
        LOGGER.logp(Level.FINE, "WARManifestProcessor", "processBCP", "cp = {0}", new Object[] { cp });
        process(queryParams, attrs, BUNDLE_CLASSPATH, cp);
    }

    /**
     * JAR visitor implementation.
     */
    private static final class JarVisitorImpl implements JarHelper.Visitor {

        /**
         * Constant for {@code WEB-INF/lib} directory.
         */
        private static final String LIB_DIR = "WEB-INF/lib/";

        /**
         * Constant for {@code .jar} extension.
         */
        private static final String JAR_EXT = ".jar";

        /**
         * Resolved libraries.
         */
        private final List<String> libs = new ArrayList<String>();

        /**
         * Resolved jar file names.
         */
        private final List<String> jarNames = new ArrayList<String>();

        /**
         * JAR file input stream.
         */
        private final JarInputStream jis;

        /**
         * Create a new instance.
         * 
         * @param is JAR input stream
         */
        JarVisitorImpl(final JarInputStream is) {
            this.jis = is;
        }

        @Override
        public void visit(final JarEntry je) {
            String name = je.getName();
            if (!je.isDirectory() && name.endsWith(JAR_EXT)) {
                jarNames.add(name);
                if (name.startsWith(LIB_DIR)) {
                    String jarName = name.substring(LIB_DIR.length());
                    if (!jarName.contains("/")) {
                        // only jar files directly in lib dir are considered
                        // as library jars.
                        libs.add(name);
                        // calculated classpaths referenced from this jar
                        try {
                            JarInputStream libJarIs = new JarInputStream(jis);
                            try {
                                String classPath = libJarIs.getManifest().getMainAttributes().getValue(Name.CLASS_PATH);
                                processCP(jarName, classPath);
                            } finally {
                                libJarIs.closeEntry();
                            }
                        } catch (IOException e) {
                            // TODO(Sahoo): Proper Exception Handling
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        }

        /**
         * Process class-path for the given entry.
         * 
         * @param entryName the entry being processed
         * @param classPath the class-path
         */
        private void processCP(final String entryName, final String classPath) {

            if (classPath == null || classPath.isEmpty()) {
                return;
            }
            LOGGER.logp(Level.FINE, "WARManifestProcessor", "visit", "jar {0} has a Class-Path entry of {1}", new Object[] { entryName, classPath });
            try {
                String referencedJarName;
                referencedJarName = URI.create(entryName).resolve(classPath).toString();
                LOGGER.logp(Level.INFO, "WARManifestProcessor", "visit", "Resolved Class-Path {0} to entry name {1} ",
                        new Object[] { classPath, referencedJarName });
                if (!libs.contains(referencedJarName)) {
                    libs.add(referencedJarName);
                }
                // TODO(Sahoo): Ideally we are supposed to traverse the
                // dependency, but some other time.
            } catch (Exception e) {
                LOGGER.logp(Level.WARNING, "WARManifestProcessor", "visit",
                        "Unexpected exception while trying to compute" + " referenced classpath for " + entryName, e);
            }
        }

        /**
         * Get the resolved libraries.
         * 
         * @return list of library names
         */
        public List<String> getLibs() {
            return libs;
        }

        /**
         * Get the JAR file names.
         * 
         * @return list of JAR names
         */
        public List<String> getJarNames() {
            return jarNames;
        }
    }

    /**
     * Process import packages.
     *
     * @param queryParams query parameters
     * @param attrs the attributes to store the result
     */
    private static void processIP(final Map<String, String> queryParams, final Attributes attrs) {

        process(queryParams, attrs, IMPORT_PACKAGE, DEFAULT_IMPORT_PACKAGE);
    }

    /**
     * Remove digest and magic manifest entries.
     *
     * @param manifest the manifest to process
     */
    private static void processSignatures(final Manifest manifest) {
        for (Attributes attrs : manifest.getEntries().values()) {
            // toArray() is called to clone the attrs, as we want to modify
            // attrs in the loop
            for (Object key : attrs.keySet().toArray()) {
                String keyName = key.toString();
                // Attributes
                // The signature attributes are x-Digest-y or x-Digest and Magic
                if (keyName.endsWith("-Digest") || keyName.contains("-Digest-") || keyName.equals("Magic")) {
                    attrs.remove(key);
                }
            }
        }
    }

    /**
     * Convert to class-path.
     *
     * @param cpJars class-path JAR files
     * @param allJarNames all JAR file names
     * @return class-path string
     */
    private static String convertToCP(final List<String> cpJars, final List<String> allJarNames) {

        StringBuilder cp = new StringBuilder();
        for (String cpJar : cpJars) {
            if (!allJarNames.contains(cpJar)) {
                LOGGER.logp(Level.INFO, "WARManifestProcessor", "convertToCP", "Excluding {0}, as there is no jar by this name " + "in the war",
                        new Object[] { cpJar });
                continue;
            }
            if (cp.length() > 0) {
                cp.append(",");
            }
            cp.append(cpJar);
        }
        return cp.toString();
    }

    /**
     * Process a manifest query.
     * 
     * @param queryParams query parameters
     * @param attrs attributes storing the query result
     * @param key manifest entry
     * @param defaultValue default value
     */
    private static void process(final Map<String, String> queryParams, final Attributes attrs, final String key, final String defaultValue) {

        String deployerOption = queryParams.get(key);
        String developerOption = attrs.getValue(key);
        String finalOption = defaultValue;
        if (deployerOption != null) {
            finalOption = deployerOption;
        } else if (developerOption != null) {
            finalOption = developerOption;
        }
        if (finalOption != null && !finalOption.equals(developerOption)) {
            attrs.putValue(key, finalOption);
        }
    }
}
